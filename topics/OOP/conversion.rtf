{\rtf1\ansi\ansicpg1252\cocoartf2759
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-BoldItalic;\f1\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red117\green117\blue117;\red60\green57\blue1;\red129\green255\blue255;
\red117\green117\blue117;\red60\green57\blue1;\red117\green117\blue117;\red0\green0\blue0;\red255\green255\blue255;
\red101\green191\blue215;\red233\green88\blue99;\red150\green120\blue195;\red183\green229\blue121;\red182\green234\blue200;
\red255\green255\blue255;\red182\green234\blue200;}
{\*\expandedcolortbl;;\cssrgb\c53230\c53231\c53230;\cssrgb\c30311\c28229\c0;\cssrgb\c56043\c100000\c100000;
\cssrgb\c53230\c53231\c53230;\cssrgb\c30311\c28229\c0;\cssrgb\c53406\c53406\c53206;\cssrgb\c0\c0\c0;\cssrgb\c100000\c100000\c99985\c0;
\cssrgb\c45948\c79381\c87445;\cssrgb\c93867\c43950\c46352;\cssrgb\c65612\c55845\c80735;\cssrgb\c76301\c90759\c54732;\cssrgb\c75955\c92833\c82313;
\cssrgb\c100000\c100000\c100000\c0;\cssrgb\c75997\c92870\c82458;}
\margl1440\margr1440\vieww14920\viewh17760\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\qc\partightenfactor0

\f0\i\b\fs50 \cf2 \ul \ulc2 Classes and Objects
\f1\i0\b0\fs24 \cf3 \ulnone \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf3 \
\
\
A class is a blueprint or prototype the defines the variables and the methods (functions) common to all objects of a certain kind. An example of a class in Python would be:\
\
\cf4 class Car:\
	def __init__(self, brand, model, year):\
		self.brand = brand\
		self.model = model\
		self.year = year\
\
	def start_engine(self):\
		print("Engine Started")\cf3 \
\
In this example, [ Car ] is the class. It has an __init__ method that is used to initialize new objects of this class, and a [ start_engine ] method that all [ Car ] objects will have.\
\
\
\
An object is an instance of a class. You can create an object of the [ Car ] class like so:\
\
\cf4 my_car = Car("Toyota", "Supra", 2021)\cf3 \
\
In this example, [ my_car ] is an object of the [ Car ] class, with brand "Toyota", model "Corolla", and year 2021. You can call the methods of the class on this object like this:\
\
\cf4 my_car.start_engine()	# prints "Engine started"\cf3 \
\
\
\
Each object has its own values for the variables defined in the class, and can use the methods defined in the class. You can create as many objects of a class as you need, and they are all independent of each other. If you change a variable in one object, it does not affect other objects.\
\
In summary, a class is like a blueprint, and an object is something you build based on that blueprint. The class defines what variables and methods an object will have, and the object is an instance of the class with actual values.\
\
\
\
Benefits of using classes and objects in OOP:\
\
Modularity:\
The source code for an object can be written and maintained independently of the source code for other objects. Once created, an object can be easily passed around inside the system.\
\
Information-hiding:\
By interacting only with an object's methods, the details of its internal implementation remain hidden from the outside world.\
\
Code Re-usability:\
If an object already exists (perhaps written by another person), you can use that object in your program. This allows specialists to implement/test/debug complex, task-specific objects, which you can then trust to run your own code.\
\
Plug-ability & Debugging Ease:\
If a particular object turns out to be problematic, you can simply remove it from your application and plug in a different object as its replacement. This is analogous to fixing mechanical problems in the real world. If a bolt breaks, you replace it, not the entire machine.\
\
Encapsulation:\
A class or object can encapsulate functionality and data into one reusable package. the data\
(attributes) and code (methods) are tied together as a self-contained unit called an object.\
This encapsulation helps manage complexity by keeping the interactions between objects under\
control.\
\
Inheritance:\
Classes can inherit common properties and functionality from other classes. This allows for more efficient and consistent code by allowing classes to share, extend, and override configurations and behaviors defined in other classes.\
\
Polymorphism:\
Polymorphism allows a single interface to represent different types of objects at runtime. This means that different classes can define the same method or property and you can use objects of different classes interchangeably.\
\
These benefits make OOP a popular choice for large, complex software systems and applications where ease of maintenance, rapid development, and code reusability are important.\
\
\
\
\
\
\
\
\
\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\qc\partightenfactor0

\f0\i\b\fs50 \cf5 \ul \ulc5 Inheritance
\f1\i0\b0\fs24 \cf3 \ulnone \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf3 \
\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf6 Inheritance is a fundamental principle of OOP that allows one class to inherit properties and methods from another class. It promotes the concept of reusability and is a way to create a new class using properties of an existing class without modifying it.\
\
Key Concepts:\
\
\cf3 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf3 Base Class (Parent Class):\
The class whose properties and methods are inherited is known as the base case or parent class.\
\
Derived Class (Child Class):\
The class that inherits properties from another class is known as the derived class or child class.\
\
Inheritance Types:\
There are several types of inheritance, including single, multiple, multilevel, hierarchical, and hybrid inheritance. The type of inheritance implemented depends on the programming language used.\
\
Method Overriding:\
In the derived classes, you can modify the behavior of methods inherited from the base class. This is known as method overriding.\
\
Access Modifiers:\
These define the accessibility of the properties and methods of a class. Common access modifiers include public, private, and protected.\
\
\
\
Example of inheritance in Python:\
\
\
\cf4 class Animal:	# Base class\
	def __init__(self, name):\
		self.name = name\
\
	def speak(self):\
		pass	# To be defined by subclass\
\
class Dog(Animal):	# Derived class\
	def speak(self):\
		return "woof!"\
\
class Cat(Animal):	# Derived class\
	def speak(self):\
		return "Meow!"\
\
\
\cf3 In this example, [ Dog ] and [ Cat ] classes inherit from the Animal class. Both [ Dog ] and [ Cat ] override the [ speak ] method of Animal. Now, if you create instance of [ Dog ] and [ Cat ] you can call the [ Speak ] method on them:\
\
\
\cf4 fido = Dog("Fido")\
print(fido.speak())		# prints "Woof!"\
\
whiskers = Cat("Whiskers")\
print(whiskers.speak())		# prints "Meow!"\cf3 \
\
\
\
Inheritance allows for more organized and manageable code, making it easier to create and maintain applications. The derived classes have their own methods and can also use the methods of the base class, reducing code duplication.\
\
\
\
More Examples:\
\
\
Example 1 (using the [ super() ] function):\
\
The [ super() ] function in Python is used in the child class to refer to the parent class without explicitly naming it. It's useful especially in cases of multiple inheritance where you want to avoid naming the parent class explicitly.\
\
\
\cf4 class Mammal:\
	def __init__(self, mammalName):\
		print(mammalName, " is a warm-blooded animal.")\
\
class Dog(Mammal):\
	def __init__(self):\
		print("Dog has four legs.")\
		super().__init__("Dog")\
\
d1 = Dog()\
\
\
# The output would be:\
# "Dog has four legs."\
# "Dog is a warm-blooded animal."\cf3 \
\
\
Breakdown:\
When [ d1 = Dog() ] is executed, it called the [ __init__ ] method in the dog class. The [ Dog ] classes [ __init__ ] method first prints "Dog has four legs." Then, [ super().__init__("Dog") ] is called. This calls the [ __init__ ]method of the Mammal class (the parent class), passing "Dog" as an argument. The mammal classes [ __init__ ] method prints "Dog is a warm-blooded animal."\
\
\
\
Example 2 (Multiple Inheritance):\
\
Python supports multiple inheritance, where a class can be derived from more than one base classes.\
\
\
\cf4 class Animal:\
	def eats(self):\
		return "Eats food"\
\
class Bird:\
	def flies(self):\
		return "Flies in the sky"\
\
class Sparrow(Animal, Bird):\
	pass\
\
s = Sparrow()\
print(s.eats())		# prints "Eats food"\
print(s.files())	# prints "Flies in the sky"\cf3 \
\
\
In this example, [ Sparrow ] is derived from both [ Animal ] and [ Bird ] classes, and inherits methods from both.\
\
\
\
Example 3 (Method Overriding):\
\
In Python, method overriding occurs by simply defining in the child class a method with the same name of a method in the parent class.\
\
\
\cf4 class Bird:\
	def intro(self):\
		print("There are many types of birds.")\
\
	def flight(self):\
		print("Most of the birds can fly but some cannot.")\
\
class sparrow(Bird):\
	def flight(self):\
		print("Sparrows can fly.")\
\
class ostrich(Bird):\
	def flight(self):\
		print("Ostriches cannot fly.")\
\
b1 = Bird()		\
b2 = sparrow()	\
b3 = ostrich()	\
\
b1.intro()	# "There are many types of birds."\
b1.flight()	# "Most of the birds can fly but some cannot."\
\
b2.intro()	# "There are many types of birds."\
b2.flight()	# "Sparrows can fly."\
\
b3.intro()	# "There are many types of birds."\
b3.flight()	# "Ostriches cannot fly."\cf3 \
\
\cf4 # In this example, sparrow and ostrich classes override the flight method of the bird class\cf3 \
\
\
When [ b1.intro() ] and [ b1.flight() ] are called, it prints "There are many types of birds." and "Most of the birds can fly but come cannot." because [ b1 ] is an instance of the [ Bird ] class.\
\
When [ b2.intro ] and [ b1.flgiht ] are called, it prints "There are many types of birds." and "Sparrows can fly." because b2 is an instance of the sparrow class. The [ intro() ] method is inherited from the [ Bird ] class and the [ flight() ] method is overridden in the [ sparrow ] class.\
\
When [ b3.into() ] and [ b3.flight() ] are called, it prints "There are many types of birds." and "Ostriches cannot fly." because [ b3 ] is an instance of the [ ostrich ] class. The [ intro() ] method is inherited from the [ Bird ] class and the [ flight() ] method is overridden in the [ ostrich ] class.\
\
\
\
\
\
\
\
\
\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\qc\partightenfactor0

\f0\i\b\fs50 \cf5 \ul \ulc5 Encapsulation
\f1\i0\b0\fs24 \cf3 \ulnone \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf3 \
\
\
Encapsulation is one the fundamental concepts in OOP. It describes the idea of wrapping data and the methods that work on data within one unit. This puts restrictions on accessing variables and methods directly and can prevent the accidental modification of data.\
\
\
# Breaking it down:\
\
\
Data Hiding:\
The implementation of the class is hidden from other classes, and can only be accessed through the methods of their current class. This is also known as data hiding.\
\
Accessors and Mutators: \
To achieve encapsulation in Python, you can use private attributes and provide public getter and setter methods to modify and access the attributes. These are often referred to as accessors (getters) and mutators (setters).\
\
Abstraction:\
Encapsulation also allows a class to change its implementation without affecting other parts of the code, which is known as abstraction. \
\
\
\
Example in Python:\
\
\
\cf4 class Computer:		# define a class named Computer\
\
	def __init__(self):		# initialize method or constructor for the class\
		self.__maxprice = 900	# private attribute, not directly accessible from outside the class\
\
	def sell(self):		# public method to print the selling price\
		print("Selling Price: \{\}".format(self.__maxprice))\
\
	def setMaxPrice(self, price):	# public method (setter) to set the price of the computer\
		self.__maxprice = price 	# modifying the private attribute within the class\
\
c = Computer()	# create an object of the computer class\
c.sell()	# call the sell method, it will print the initial price\
\
c.__maxprice = 1000		# try to directly change the price\
c.sell()	# call the sell method, it will still print the initial price because we can't\
																		# change it directly\
# using setter function		# use the setter method to change the price\
c.setMaxPrice(1000)		# now, when we call the sell method, it will print the updated price\
c.sell()\cf3 \
\
\
In the script we defined a [ Computer ] class. We are using [ __init__() ] method to store the maximum selling price of [ Computer ]. We tried to modify the price. However, we can't change it because Python treats the [ __maxprice ] as private attributes.\
\
As a result, to change the value, you have to use a setter method [ setMaxPrice() ] which takes price as parameter.\
\
The output would be:\
Selling Price: 900\
Selling Price: 900\
Selling Price: 1000\
\
Encapsulation helps us to avoid data being modified accidentally and provides a way to protect and control access to attributes in a class.\
\
Another way to sum it up:\
The [ Computer ] class encapsulates the [ __maxprice ] attribute and provides the [ sell ] method to display it, and the [ setMaxPrice ] method to change it. The [ __maxprice ] attribute is not directly accessible from outside the class - trying to change it directly won't have any effect. Instead, you have to use the [ setMaxPrice ] method to modify it.\
\
\
\
Another Example:\
\
A setter method provides controlled access to modify the values of private attributes. This is useful because you can add checks or validation within the setter method to prevent invalid or inconsistent states for your objects.\
\
\
\cf4 class Myclass:\
	def __init__(self):\
		self.__my_attribute = 0\
\
	def set_my_attribute(self, value):\
		if value < 0:\
			raise ValueError("Value cannot be negative")\
		self.__my_attribute = value\
\
obj = Myclass()\
obj.set_my_attribute(10)	# this modifies the __my_attribute value to 10\cf3 \
\
\
In this example, [ set_my_attribute ] is a setter method that modifies the value of [ __my_attribute ]. It also includes a check to ensure that the value cannot be set to a negative number. If you try to set it to a negative number, it will raise a ValueError.\
\
\
\
Some Best Practices For Using Encapsulation In OOP:\
\
Data Hiding:\
Keep the data hidden and not directly accessible from outside the class. Use private visibility for attributes which should no be accessible directly.\
\
Use Accessors and Mutators:\
Provide public getting and setter methods (accessors and mutators) to access and modify the\
private attributes of a class. This allows you to control how important variables are read and written to.\
\
Validation:\
You can add validation logic in setter methods to protect your data from getting into an inconsistent or invalid state.\
\
Abstraction:\
Encapsulation is a way to achieve data abstraction. The user will have the information on what methods do, but they won't need to know how they do it.\
\
Reduce Coupling:\
Encapsulation can help reduce coupling between different parts of your program, making it easier to modify without affecting other parts of the code.\
\
Consistency:\
Be consistent in how you apply encapsulation in your code. If you start using getters and setters for accessing properties of the class, stick to it throughout your code.\
\
Avoid Excessive Use:\
While encapsulation is important, it's also crucial not to overuse it. Not every single variable needs to be private with getters and setters. If a variable doesn't need any special behavior or constraints, it might not need to be encapsulated. \
\
\
\
\
\
\
\
\
\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\qc\partightenfactor0

\f0\i\b\fs50 \cf5 \ul \ulc5 Polymorphism
\f1\i0\b0\fs24 \cf6 \ulnone \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf6 \
\
\
The word "Polymorphism" comes from Greek and means "many shapes". In programming, it refers to the ability of an object to take on many forms. The most common use of polymorphism in OOP occurs when a parent class reference is used to refer to a child class object.\
\
Breakdown:\
\
Subtyping:\
Subtyping, also known as subtype polymorphism, is a form of polymorphism in which a subclass is datatype that is a subtype of a superclass. The superclass can be used to refer to the subclass object. In other words, a reference variable of a superclass can point to an object of the subclass.\
\
Method Overriding:\
Method overriding is a feature that allows a subclass to provide a different implementation for a method that is already defined in its superclass. This is used to achieve runtime polymorphism.\
\
Operator Overloading:\
Operator overloading is a type of polymorphism in which an operator is overloaded to provide the special meaning to the user-defined data type. Operator overloading is used to perform operations on user-defined data type like complex numbers, fractions, etc.\
\
\
Example of polymorphism in Python (also previously used to demonstrate inheritance):\
\
\
\cf4 class Bird:\
	def intro(self):\
		print("There are many types of birds.")\
\
	def flight(self):\
		print("Most of the birds can fly but some cannot.")\
\
class sparrow(Bird):\
	def flight(self):\
		print("Sparrows can fly.")\
\
class ostrich(Bird):\
	def flight(self):\
		print("Ostriches cannot fly.")\
\
bird1 = Bird()\
bird2 = sparrow()\
bird3 = ostrich()\
\
bird1.intro()	# "There are many types of birds."\
bird1.flight()	# "Most of the birds can fly but some cannot."\
\
bird2.intro()	# "There are many types of birds."\
bird2.flight()	# "Sparrows can fly."\
\
bird3.intro()	# "There are many types of birds."\
bird3.flgiht()	# "Ostriches cannot fly."\cf6 \
\
\
In the above program, we defined two classes [ sparrow ] and [ ostrich ], both are subclasses of [ Bird ]. A method named [ flight ] is created in [ Bird ] class and overridden in both subclasses. This is a perfect example of polymorphism as the method [ flight ] is taking multiple forms.\
\
Polymorphism allows us to define methods in the child class with the same name as defined in their parent class. As the key aspect of polymorphism is that it provides flexibility and loose coupling so that code can be extended and easily maintained over time.\
\
\
\
The previous explanation focused on inheritance. Inheritance is a mechanism where you can derive a class from another class for a hierarchy of classes that share a set of attributes and methods. In the example, [ sparrow ] and [ ostrich ] classes are derived from the [ Bird ] class, hence they inherit the intro method from the [ Bird ] class.\
\
The current explanation focuses on polymorphism, which is a concept that allows objects of different classes to be treated as objects of a superclass. In the context of the example, both [ sparrow ] and [ ostrich ] classes override the [ flight ] method of the [ Bird ] class. When we call the [ flight ] method on an object of type [ Bird ], [ sparrow ], or [ ostrich ], the appropriate version of the method is executed based on the actual type of the object. This is polymorphism in action.\
\
\
\
# Further Explanation:\
\
\
Inheritance:\
Is the mechanism where a class (the subclass) can derive or inherit properties and methods from another class (the superclass). In the given example, [ sparrow ] and [ ostrich ] are subclasses that inherit from the [ Bird ] superclass, and this they inherit the [ into ] and [ flight ] methods.\
\
Polymorphism:\
On the other hand, is the ability of the subclasses to provide their own specific  implementation of a method that is already provided by their superclass. In the example, the [ sparrow ] and the [ ostrich ] subclasses provide their own implementation of the flight method. This is a from of polymorphism known as method overriding.\
\
So, when a method is invoked, which version of the method is to be executed is determined based on the type of object being invoked on. If it's a [ Bird ] object, [ Bird ]s version of [ flight ] is called. If it's a [ sparrow ]. or [ ostrich ] object, their respective version of [ flight ] are called. This ability to "take many forms" is the essence of polymorphism.\
\
\
\
Common use cases:\
\
\
Creating Reusable Code:\
Polymorphism allows you to write code that does not need to be changed when a new derived class is added, which makes your code more reusable. You can write a function or method that uses a base class type and it will be able to handle any objects of classes derived from that base class.\
\
Implementing Interface Polymorphism:\
In languages that support interfaces (like Java or C#), polymorphism is often used to implement classes that share the same methods but have different implementations. This is a powerful way to decouple your code and make it more modular and flexible.\
\
Design Patterns:\
Many design patterns in OOP use polymorphism. For example, in the Strategy pattern, a context object contains a reference to a strategy object, and delegates all requests to that object. The strategy object can be changed to change the behavior of the context object.\
\
Abstract Classes and Methods:\
In some languages, you can define abstract classes and methods that provide a base level of functionality, but require subclasses to provide specific implementations. This is a form of polymorphism.\
\
Graphics and User Interface:\
In graphical and user interface programming, polymorphism is used extensively. For example, you might have a base [ Shape ] class and derived classes like [ Circle ], [ Rectangle ], etc. You can then write code that works with [ Shape ] objects, and it will work with any derived shape objects.\
\
Game programming:\
In game programming, polymorphism is used to manage and manipulate collections of different types of game objects. For example, you might have a base [ GameObject ] class and derived classes like [ Player ], [ Alien ], [ Asteroid ], etc.\
\
\
The main benefit of polymorphism is that it allows you to write more flexible and reusable code by allowing objects of different classes to be treated as objects of a common superclass.\
\
\
\
\
\
\
\
\
\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\qc\partightenfactor0

\f0\i\b\fs50 \cf5 \ul \ulc5 Abstraction
\f1\i0\b0\fs24 \cf6 \ulnone \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf6 \
\
\
Abstraction is the process of hiding the complex details of an operation while providing a simpler interface.\
\
\
Data Abstraction:\
Data abstraction is about providing only essential information to the outside world while hiding their background details, i.e., how the data is stored and operations are performed. In other words, the user interacts with only the information that is necessary, while the underlying complexities and hidden from the user.\
\
Method Abstraction:\
This is achieved by creating methods that perform complex operations, but providing a simple interface for them. The user doesn't need to know how the method does what it does- they just need to know what it does.\
\
Abstract Classes and Methods:\
In some programming languages like Java & C#, you can create abstract classes and methods. An abstract class is a class that cannot be instantiated and is meant to be subclassed. It can contain abstract methods (methods declared without an implementation) as well as  concrete methods (methods with an implementation). Subclasses of an abstract class are generally expected to provide an implementation for the abstract methods.\
\
Interface:\
An interface is a completely abstract class that contains only abstract methods. In languages that support interfaces, they are a powerful way to achieve full abstraction and multiple inheritance.\
\
Encapsulation and Information Hiding:\
Abstraction is closely related to encapsulation and information hiding. Encapsulation is the bundling of data and methods that operate on that data within one unit, and information hiding is about making the data inaccessible to the outside world. Abstraction takes this a step further by not only hiding the data, but also by hiding how the methods of a class are implemented.\
\
\
\
The main advantage of abstraction is that it reduces complexity by breaking down complex systems into smaller, more manageable parts. This is also increases the maintainability, reusability, and modularity of the code. It allows you to change the implementation of an abstracted operation without affecting the rest of the code, as long as the interface stays the same.\
\
\
\
Consider an example of a payment processing system. In this system, we have different payment methods like Credit Card, Debit Card, and PayPal. Each payment method follows the same process: authorize the payment and then charge the payment. However, the implementation details for each payment method are different.\
\
\
In Python:\
\
\
\cf4 from abc import ABC, abstractmethod\
\
class PaymentMethod(ABC):	# define an abstract base class- PaymentMethod\
	@abstractmethod		# declare an abstract method- authorize\
	def authorize(self):\
		pass\
\
	@abstractmethod		# declare and abstract method- charge\
	def charge(self):\
		pass\
\
class CreditCard(PaymentMethod):	# define a concrete class- CreditCard, that inherits from PaymentMethod\
	def authorize(self):	# provide and implementation for the- authorize method\
		print("Authorizing Credit Card")\
\
	def charge(self):	# provide an implementation for the- charge method\
		print("Charging Credit Card")\
\
class PayPal(PaymentMethod):	# define a concrete class- PayPal that inherits from PaymentMethod\
	def authorize(self):	# provide an implementation for the- authorize method\
		print("Authorizing PayPal Account")\
\
	def charge(self):	# provide an implementation for the- charge method\
		print("Charging PayPal Account")\
\
class PaymentProcessor:		# define a class- PaymentProcessor\
	def process_payment(self, payment_method):		# Define a method- process_payment that takes a PaymentMethod object\
		payment_method.authorize()	# call the- authorize method on the PaymentMethod object\
		payment_method.charge()		# class the- charge method on the- PaymentMethod object\
\
payment_processor = PaymentProcessor()\
\
credit_card = CreditCard()	# create a PaymentProcessor object\
payment_processor.process_payment(credit_card)	# use the PaymentProcessor to process the payment with the- CreditCard\
\
paypal = PayPal()	# create a PayPal object\
payment_processor.process_payment(paypal)	# use the PaymentProcessor to process the payment with PayPal\cf6 \
\
\
In this code, [ PaymentMethod ] is an abstract base class that declares two abstract methods: [ authorize ] and [ charge ]. [ CreditCard ] and [ PayPay ] are concrete classes that inherit from [ PaymentMethod ] and provide their own implementations of these methods.\
\
The [ PaymentProcessor ] class has a [ process_payment ] method that takes a [ PaymentMethod ] object and calls its [ authorize ] and [ charge ] methods. This method doesn't need to know what specific type [ PaymentMethod ] it's dealing with, it just knows that it can call [ authorize ] and [ charge ] on it. This is abstraction in action.\
\
\
 \
More detailed explanation:\
\
In the system, [ PaymentMethod ] is an abstract base class (ABC) that defines a common interface for all payment methods. This interface includes two methods: [ authorize ] and [ charge ]. These methods are marked as abstract, meaning they have no implementation in [ PaymentMethod ] and must be implemented by any concrete (i.e., non-abstract) subclass.\
\
[ CreditCard ] and [ PayPal ] are concrete classes that inherit from [ PaymentMethod ] and provide their own implementations of the [ authorize ] and [ charge ] methods. These implementations contain the specific steps required to authorize and charge a payment using each method.\
\
The [ PaymentProcessor ] class represents the part of the system that processes payments. It has a [ process_payment ] method that takes an object of type [ PaymentMethod ] and called its [ authorize ] and [ charge ] methods. This method doesn't need to know the details of how each payment method authorized and charges payments; it just needs to know that it can call [ authorize ] and [ charge ] on any [ PaymentMethod ] object.\
\
This is where the power of abstraction comes in. By defining a common interface for all payment methods, we can write code in [ PaymentProcessor ] that works with any payment method, regardless of its specific implementation. This makes [ PaymentProcessor ] more flexible and easier to maintain. If we want to add a new payment method in the future, we just need to create a new class that implements the [ PaymentMethod ] interface; we don't need to change any code in [ PaymentProcessor ].\
\
\
Abstraction in this context is used to hide the complex details of authorizing and charging different types of payments, while providing a simple, consistent interface for processing any type of payment. This reduces complexity, improves maintainability, and makes the code more flexible and extensible.\
\
\
\
\
\
\
\
\
\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\qc\partightenfactor0

\f0\i\b\fs50 \cf5 \ul \ulc5 Association
\f1\i0\b0\fs24 \cf6 \ulnone \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf6 \
\
\
Association represents a relationship between two or more objects\
\
\
Some key points:\
\
Definition:\
Association is a "using" relationship between two or more objects. It's a way for one objects to interact with another, without necessarily having a strong dependency. For example, a [ Driver ] object might have an association with a [ car ] object, because the driver uses the car\
\
Multiplicity:\
Association can be one-to-one, one-to-many, many-to-one, or many-to-many. For example, a [ Teacher ] object and a [ Student ] object could have a many-to-many association, because a teacher can teach many students, and a student can have many teachers.\
\
Directionality:\
Association can be unidirectional or bidirectional. In a unidirectional association, one object is aware of another and can interact with it, but not vice versa. In a bidirectional association, both objects are aware of each other.\
\
Navigation:\
The direction of the association between two classes is called navigation. It can be either from one class to another or vice versa, or both.\
\
Association vs Aggregation vs Composition:\
These are three types of relationships in OOP. Association is the most general, aggregation is a special form of association (a "has-a" relationship, where the child can exist independently of the parent), and composition is a stronger form of aggregation (where the child cannot exist independently of the parent).\
\
\
\
# Python Examples:\
\
\
# one-to-one relationship:\
\
\
\cf4 class Car:	# define the car class\
	def __init__(self, model):	# the constructor method for the Car class\
		self.model = model	# an instance variable 'model' is created and set to the value passed\
																				# as an argument\
class Driver:	# define driver class\
	def __init__(self, name):	# the constructor method for the Driver class\
		self.name = name	# an instance variable 'name' is created and set to the value passed\
																				# as an argument\
	def drive(self, car):	# a method 'drive' that takes a Car instance as an argument\
		print(f"\{self.name\} is driving a \{car.model\} car.")	# prints a message using the 'name'\
											# of the Driver instance and the 'model' of the car\
car = Car("Toyota")	# create a Car instance 'car' with the model "Toyota"\
driver = Driver("John")	# create a Driver instance 'driver' with the name "John"\
driver.drive(car)	# call the 'drive' method on the 'driver' instance, passing in the 'car' instance\cf6 \
\
\
In this example, the [ Driver ] class has an association with the [ Car ] class, because it uses a [ Car ] object in its [ drive ] method. This is a one-to-one, unidirectional association. \
\
This is a one-to-one relationship because one instance of the [ Driver ] class is associated with one instance of the [ Car ] class in the drive method. The [ drive ] method is called on one [ Driver ] instance and takes one [ Car ] instance as an argument.\
\
It's important to note that this doesn't mean a [ Driver ] can only ever driver one  [ Car ] or vice versa. If you had multiple [ Car ] instances, you could call [ drive ] on the same [ Driver ] with each [ Car ]. But in the context of a single call to [ drive ], it's a one-to-one relationship because one [ Driver ] is driving one [ Car ].\
\
\
\
one-to-many relationship:\
\
Let's consider a scenario where a Teacher can have many Students. This is a one-to-many relationship because one Teacher is associated with multiple Student instances.\
\
\
\cf4 class Student:\
	def __init__(self, name):\
		self.name = name\
\
class Teacher:\
	def __init__(self, name):\
		self.name = name\
		self.students = [] # this will hold the list of students for the teacher\
\
	def add_student(self, student):\
		self.students.append(student)\
\
	def list_students(self):\
		for student in self.students:\
			print(f"\{self.name\} is teaching \{student.name\}.")\
\
# create some Student instances\
student1 = Student("Alice")\
student2 = Student("Bob")\
student3 = Student("Charlie")\
\
# create a Teacher instance\
teacher = Teacher("Mr. Anderson")\
\
# add the students to the teacher\
teacher.add_student(student1)\
teacher.add_student(student2)\
teacher.add_student(student3)\
\
# list the students for the teacher\
teacher.list_students()\cf6 \
\
\
In this code, the [ Teacher ] class has a method [ add_student ] that takes a [ Student ] instance and adds it to the [ students ] list. The [ list_students ] method then goes through the [ students ] list and prints a message for each one. This demonstrates a one-to-many relationship because one [ Teacher ] is associated with many [ Student ] instances.\
\
\
\
many-to-many relationship:\
\
\
A many-to-many relationship occurs when multiple instances of one class are associated with multiple instances of another class. Consider a situation where a Student can enroll in multiple Courses, and a Course can have multiple Students.\
\
\
\cf4 class Student:\
	def __init__(self, name):\
		self.name = name\
		self.courses = [] # this will hold the list of courses for the student\
\
	def enroll(self, course):\
		self.courses.append(course)\
		course.students.append(self)\
\
class Course:\
	def __init__(self, name):\
		self.name = name\
		self.students = [] # this will hold the list of students in the course\
\
	def list_students(self):\
		for student in self.students:\
			print(f"\{studnet.name\} is enrolled in \{self.name\}.")\
\
# create some Course instances\
course1 = Course("Math")\
course2 = Course("English")\
\
# create some student instances\
studnet1 = Student("Alice")\
student2 = Student("Bob")\
\
# enroll the students in the courses\
studnet1.enroll(course1)\
studnet1.enroll(course2)\
studnet2.enroll(course1)\
\
# this the students int he courses\
course1.list_students()\
course2.list_students()\cf6 \
\
\
In this code, both the [ Student ] and [ Course ] classes have a list to hold their associations (the [ courses ] list in [ Student ] and the [ students ] list in [ Course ]). The [ enroll ] method in [ Student ] adds a [ Course ] to the [ courses ] list an also adds the [ Student ] to the [ students ] list in [ Course ]. This sets up a  many-to-many relationship, because a [ Student ] can be enrolled in many [ Courses ], and a [ Course ] can have many [ Students ].\
\
\
\
many-to-one relationship:\
\
\
A many-to-one relationship occurs when multiple instances of one class are associated with a single instance of another class. Consider a situation where a Child has one Mother, but a Mother can have multiple Children.\
\
\
\cf4 class Child:\
	def __init__(self, name, mother):\
		self.name = name\
		self.mother = mother # each child has one mother\
		mother.children.append(self) # the mother has another child\
\
class Mother:\
	def __init__(self, name):\
		self.name = name\
		self.children = [] # this will hold the list of children for the mother\
\
	def list_children(self):\
		for child in self.children:\
			print(f"\{self.name\} is the mother of \{child.name\}.")\
\
# create a Mother instance\
mother = Mother("Mrs. Smith")\
\
# create some Child instances\
child1 = Child("Alice", mother)\
child2 = Child("Bob", mother)\
\
# list the children for the mother\
mother.list_children()\cf6 \
\
\
In this code, the [ Mother ] class has a list [ children ] to hold her [ Child ] instances. When a [ Child ] is created, it's given a [ Mother ] instance, and it adds itself to the [ Mother ]s [ children ] list. This sets up a many-to-one relationship, because many [ Children ] are associated with one [ Mother ].\
\
\
\
\
\
\
\
\
\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\qc\partightenfactor0

\f0\i\b\fs50 \cf5 \ul \ulc5 Aggregation
\f1\i0\b0\fs24 \cf6 \ulnone \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf6 \
\
\
Aggregation is a special form of association in OOP. It represents a "has-as"" relationship between two classes, where one class is a complex entity that consists of one or more other classes, but there is still independence of the classes.\
\
\
\
Key Points:\
\
\
Definition:\
Aggregation is a relationship where one class (the "whole" or "parent") has a reference to another class (the "part" or "child"), but the child can exist independently of the parent. For example, a Car might have an Engine. The car is the whole entity that uses the engine, but the engine could exist without the car.\
\
Independence:\
In an aggregation relationship, the child can exist independently of the parent. If the parent is deleted, the child can continue to exist. For example, if you delete a Car object, the Engine object can still exist.\
\
Lifecycle:\
The lifecycle of the child is not managed by the parent. The child can be created and deleted independently.\
\
Direction:\
Aggregation is typically a one-way relationship. The parent knows about the child, but the child does not know about the parent.\
\
\
Example:\
\
\
\cf4 class Engine:\
	def __init__(self, type):\
		self.type = type\
\
class Car:\
	def __init__(self, model, engine):\
		self.model = model\
		self.engine = engine	# the Car has an Engine\
\
# create an Engine instance\
engine = Engine("V8")\
\
# create a Car instance with Engine\
car = Car("Toyota", engine)\cf6 \
\
\
In this example, the [ Car ] class has an aggregation relationship with the [ Engine ] class. The [ Car ] has an [ Engine ], but the [ Engine ] can exist independently of the [ Car ].\
\
\
\
\
\
\
\
\
\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\qc\partightenfactor0

\f0\i\b\fs50 \cf5 \ul \ulc5 Composition
\f1\i0\b0\fs24 \cf6 \ulnone \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf6 \
\
\
Composition is a design principle in OOP where a class (the "composite" or "parent") is made up of other classes (the "components" or "children"). It represents a "part-of" relationship and is a strong form of aggregation. \
\
\
\
# Key points:\
\
\
Definition:\
Composition is a relationship where one class (The composite) contains an instance of  another class (the component). The component is part of the composite. For example, a Car might have an Engine. The car is the whole entity, and the engine is part of the car.\
\
Dependence:\
In a composition relationship, the component cannot exist independently of the composite. If the composite is deleted, the component is also deleted. For example, if you deleted a Car object, the Engine object is also deleted because it's part of the car.\
\
Lifecycle:\
The lifecycle of the component is managed by the composite. the component is created when the composite is created, and deleted when the composite is deleted.\
\
Direction:\
Composition is typically and one-way relationship. The composite knows about the component, but the component does not know about the composite.\
\
\
\
Python example:\
\
\
\cf4 class Engine:\
	def __init__(self, type):\
		self.type = type\
\
class Car:\
	def __init__(self, model, engine_type):\
		self.model = model\
		self.engine - Engine(engine_type) # the Car creates an Engine\
\
# create a Car instance with an Engine\
car = Car("Toyota", "V8")\cf6 \
\
\
In this example, the [ Car ] class has a composition relationship with the [ Engine ] class. The [ Car ] creates an [ Engine ] when it's created, so the [ Engine ] is part of the  [ Car ] and can't exist independently.\
\
\
\
The Difference Between This Example and the Example Dealing with Aggregation:\
\
\
\
The key difference between the two examples lies in the lifecycle and dependency of the [ Engine ] object with respect to the [ Car ] object.\
\
In Aggregation:\
\
\
\cf4 class Engine:\
	def __init__(self, type):\
		self.type = type\
\
class Car:\
	def __init__(self, model, engine):\
		self.model = model\
		self.engine = engine # the Car has an Engine\
\
# create an Engine instance\
engine = Engine("V8")\
\
# create a Car instance with the Engine\
car = Car("Toyota", engine)\cf6 \
\
\
The engine instance is created independently of the [ Car ] instance. The [ Car ] instance then takes an existing [ Engine ] instance as a parameter. This means the [ Engine ] can exist without the [ Car ], and if the [ Car ] is deleted, the [ Engine ] continues to exist. This is a characteristic of aggregation.\
\
\
\
In Composition:\
\
\
\cf4 class Engine:\
	def __init__(self, type):\
		self.type = type\
\
class Car:\
	def __init__(self, model, engine_type):\
		self.model = model\
		self.engine = Engine(engine_type) # the Car creates and Engine\
\
# create a Car instance with an Engine\
car = Car("Toyota", "V8")\cf6 \
\
\
The [ Car ] instance creates its own [ Engine ] instance when it's constructed. The instance cannot exist without the [ Car ] instance, and if the [ Car ] is deleted, the [ Engine ] is also deleted. This is a characteristic of composition.\
\
\
\
So, the main difference is about the dependency and lifecycle of the [ Engine ] with respect to the [ Car ]. In aggregation, the [ Engine ] can exist independently, while in composition, the [ Engine ] is fully dependent on the [ Car ].\
\
\
\
\
\
\
\
\
\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf3 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf3 \
\cf8 \
for html:\
\
\pard\pardeftab720\partightenfactor0

\fs20 \cf8 \cb9 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec10 <\cb9 \strokec11 pre\cb9 \strokec10  \cb9 \strokec12 class\cb9 \strokec10 ="\cb9 \strokec13 code-box\cb9 \strokec10 ">\cb9 \strokec14 \
    \cb9 \strokec10 <\cb9 \strokec11 code\cb9 \strokec10 >\cb9 \strokec14 \
\
    \cb9 \strokec10 </\cb9 \strokec11 code\cb9 \strokec10 >\cb9 \strokec14 \
\cb9 \strokec10 </\cb9 \strokec11 pre\cb9 \strokec10 >\cb15 \strokec16 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\fs24 \cf3 \cb1 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 \
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\qc\partightenfactor0
\cf3 __________\cf6 __________________________________________________}